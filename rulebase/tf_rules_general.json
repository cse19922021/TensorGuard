{
    "rule": "{\n    \"Root Cause\": \"Bug due to nonscalar num_bits input tensor\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `QuantizeAndDequantizeV3`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding non-scalar inputs for min or max variables\",\n    \"Argument Type\": \"Tensor with rank greater than 0\"\n}",
    "link": "\n        `CHECK` fail in `FakeQuantWithMinMaxVarsGradient`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding large input shape and rates into tf.random.gamma API, causing a CHECK fail that can trigger a denial of service attack\",\n    \"Argument Type\": \"Shape and rates\"\n}",
    "link": "\n        `CHECK` fail in `tf.random.gamma`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding large input shape and rates that trigger CHECK fail and denial of service attack\",\n    \"Argument Type\": \"TensorFlow tensor\"\n}",
    "link": "\n        `CHECK` fail in `RandomPoissonV2`\n      "
},
{
    "rule": "{\n  \"Root Cause\": \"Bug due to not validating the input 'id' of type int64, which can trigger a CHECK fail and lead to a denial of service attack.\",\n  \"Argument Type\": \"int64\"\n}",
    "link": "\n        `CHECK` fail in `Unbatch`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to passing an input to DrawBoundingBoxes that is not of dtype float.\",\n    \"Argument Type\": \"Numpy array\"\n}",
    "link": "\n        `CHECK` fail in `DrawBoundingBoxes`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding incorrect Tout input to the Eig API\",\n    \"Argument Type\": \"Type of argument: Tout\"\n}",
    "link": "\n        `CHECK` fail in `Eig`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding empty tensor inputs to the Conv2DBackpropInput API\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `Conv2DBackpropInput`\n      "
},
{
    "rule": "{\n  \"Root Cause\": \"Bug due to passing input element_shape with more than one dimension to EmptyTensorList API\",\n  \"Argument Type\": \"Shape Tensor\"\n}",
    "link": "\n        `CHECK` fail in `EmptyTensorList`\n      "
},
{
    "rule": "{\n  \"Root Cause\": \"Bug due to feeding non-scalar input separator to tf.sparse.cross function.\",\n  \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `tf.sparse.cross`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to providing empty input to Conv2D API which causes division-by-zero floating point exceptions\",\n    \"Argument Type\": \"Input\"\n}",
    "link": "\n        Floating point exception in `Conv2D`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding a multi-dimensional tensor to 'sample_rate' argument whereas it only accepts a scalar value\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `AudioSummaryV2`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to passing a scalar input `input` to `CollectiveGather` API, which is not supported and triggers a CHECK fails that can be used to trigger a denial of service attack.\", \n    \"Argument Type\": \"Scalar\"\n}",
    "link": "\n        `CHECK` fail in `CollectiveGather`\n      "
},
{
    "rule": "{\n\"Root Cause\": \"Bug due to feeding non 1D tensor input to set_shape parameter in SetSize API\",\n\"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `SetSize`\n      "
},
{
    "rule": "{\n  \"Root Cause\": \"Bug due to receiving an element_shape of a rank greater than one, which triggers a CHECK fail and can lead to a denial of service attack.\",\n  \"Argument Type\": \"Tensor element shape\"\n}",
    "link": "\n        `CHECK` fail in `TensorListFromTensor`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to passing a tensor of rank greater than one as element_shape argument to TensorListScatter and TensorListScatterV2 APIs\",\n    \"Argument Type\": \"Tensor with rank greater than one\"\n}",
    "link": "\n        `CHECK` fail in `TensorListScatter` and `TensorListScatterV2`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to passing element_shape of a rank greater than one to TensorListScatter and TensorListScatterV2.\",\n    \"Argument Type\": \"TensorShape\"\n}",
    "link": "\n        `CHECK` fail in `TensorListScatter` and `TensorListScatterV2`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to using input min or max of rank other than 1\",\n    \"Argument Type\": \"Tensor of rank other than 1\"\n}",
    "link": "\n        `CHECK` fail in `FakeQuantWithMinMaxVarsPerChannelGradient`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding a window size input array ksize with dimensions greater than the input tensor input\",\n    \"Argument Type\": \"Input array\"\n}",
    "link": "\n        `CHECK` fail in `MaxPool`\n      "
},
{
    "rule": "{\n  \"Root Cause\": \"Bug due to feeding empty input to tf.linalg.matrix_rank API\",\n  \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `tf.linalg.matrix_rank`\n      "
},
{
    "rule": "{\n\"Root Cause\": \"Assuming input tensor weights to either have the same shape as its input tensor input or to be length-0, causing a CHECK fail that can be used to trigger a denial of service attack.\",\n\"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `DenseBincount`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding an empty tensor splits causing a segfault\",\n    \"Argument Type\": \"Tensor (splits)\"\n}",
    "link": "\n        Segfault in `RaggedBincount`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to LRNGrad API accepting an output_image input tensor that is not 4-D\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `LRNGrad`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to passing an int64 type as the argument instead of int32 type, resulting in a type mismatch error and a potential denial of service attack.\",\n    \"Argument Type\": \"int64\"\n}",
    "link": "\n        `CHECK` fail in `ParameterizedTruncatedNormal`\n      "
},
{
    "rule": "{\n  \"Root Cause\": \"Bug due to running Save or SaveSlices operations over tensors of an unsupported dtype, which triggers a CHECK fail and consequently can be used to trigger a denial of service attack.\",\n  \"Argument Type\": \"Unsupported Data Type\"\n}",
    "link": "\n        `CHECK` fail in `Save` and `SaveSlices`\n      "
},
{
    "rule": "{\n  \"Root Cause\": \"Bug due to passing tensors of an unsupported dtype to Save or SaveSlices API\",\n  \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `Save` and `SaveSlices`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to providing inputs for indices, values and dense_shape that do not make a valid sparse tensor\",\n    \"Argument Type\": \"SparseTensor\"\n}",
    "link": "\n        Segfault in `SparseBincount`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding rt_nested_splits list that contains tensors of ranks other than one to the RaggedTensorToVariant API.\",\n    \"Argument Type\": \"List of Tensors\"\n}",
    "link": "\n        `CHECK` fail in `RaggedTensorToVariant`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to incorrectly sized inputs triggering CHECK failure instead of returning errors\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `FractionalMaxPoolGrad`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to providing non-scalar input for min_features or max_features\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        Segfault in `QuantizedRelu` and `QuantizedRelu6`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding nonscalar inputs for min_features or max_features\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        Segfault in `QuantizedRelu` and `QuantizedRelu6`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding empty tensor to the input_min argument of QuantizeDownAndShrinkRange API\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        Segfault in `QuantizeDownAndShrinkRange`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to feeding nonscalar input to QuantizedMatMul API.\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        Segfault in `QuantizedMatMul`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to providing min or max tensors of a rank other than one, resulting in a CHECK fail and enabling a denial of service attack.\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        `CHECK` fail in `FakeQuantWithMinMaxVarsPerChannel`\n      "
},
{
    "rule": "{\n    \"Root Cause\": \"Bug due to passing empty tensor as input to `min_input` and uninitialized tensors as `max_input` and `max_bias`.\",\n    \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        Segfault in `QuantizedBiasAdd`\n      "
},
{
    "rule": "{\n  \"Root Cause\": \"Bug due to providing empty tensor as input_min argument\",\n  \"Argument Type\": \"Tensor\"\n}",
    "link": "\n        Segfault in `Requantize`\n      "
},
